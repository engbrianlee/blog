import image from "./card.jpg";

export const meta = {
  title: "An overview of authentication with Auth0",
  description: `Auth is hard and frustrating. You require prerequisite knowledge of basic security, data flows and auth protocols. Oh! And if you mess up, you're screwed. Luckily for you (and everyone using your app!), many of these problems have been solved.`,
  date: "2020-08-10 01:00:40",
  image,
};

Auth is hard and frustrating. You require prerequisite knowledge of basic security, data flows and auth protocols. Oh! And if you mess up, you're screwed. Luckily for you (and everyone using your app!), many of these problems have been solved.

> Note: This post is WIP and currently serves as a personal reference.

<!--more-->

## Tricky Parts of OAuth2 Authorization Code Grant With PCKE

The current standard for web apps is [OAuth2](https://oauth.net/2/). Any serious web app should implement it but most tutorials don't want to have to deal with integrating an OAuth2 auth server and roll their own toy solution using a simple JWT exchange. For the zealous, you might even follow the [best practices with JWT](https://hasura.io/blog/best-practices-of-using-jwt-with-graphql). This is great to demonstrate the core concepts of authentication but should not be used in production.

An overview of OAuth2 can be found [here](https://aaronparecki.com/oauth-2-simplified/).

> TLDR; Web Apps use a flow called Authorization Code Grant for server-side authentication, and Authorization Code Grant with PCKE for client-side (ex. SPA) authentication. Authorization Code Grant with PCKE is the same as Authorization Code Grant (hence the similar names), with the exception that you use a randomly generated key (the _Key_ part of Proof _Key_ for Code Exchange) each time as a substitute for a secret. We have to do this since we don't have access to secrets client-side, as they are exposed.

An explanation of why PCKE is needed can be found [here](https://security.stackexchange.com/questions/175465/what-is-pkce-actually-protecting)

> TLDR; The reason PKCE is important is that on mobile OS, the OS allows apps to register to handle redirect URIs so a malicious app can register and receive redirects with the authorization code for legitimate apps. This is known as an Authorization Code Interception Attack. For this reason we need to generate a dynamic secret `code_verifier` per access token request.

## Authorization Code Grant with PCKE (the current (2020) best practices for authenticating SPA)

Okay so how does this flow work?

To authenticate you redirect user to `/authorize` endpoint of your auth server with query params. Among query params are `redirect_uri`, `code`, `state`, `code_challenge`, and `client_id`.

Some of the parameters are not explained too well and aren't self-explanatory:

- `state` - A random string generated by your application, which is verified by _you_ to prevent accepting arbitrary authorization codes. Anyone could redirect to your `redirect_uri` and thus you need a way to confirm that it was you who iniated the redirect.

- `nonce` - A random string generated by your application, which is verified by the auth server to prevent [replay attacks](https://en.wikipedia.org/wiki/Replay_attack). A nonce can only be used once, thus if someone, somehow, got a hold of your password/password hash, they would not be able to use it request authentication from your auth server again (this is a replay attack). Note: This isn't part of the OAuth2 spec for Authorization Code Grant and [Auth0 Docs](https://auth0.com/docs/api-auth/tutorials/nonce) says it's used for implicit flow grant. It doesn't appear on [Auth0 PCKE Docs](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce) either. It's safe to assume that this isn't being used, and the [auth0-react sdk](https://github.com/auth0/auth0-react) includes it anyways.

- `code_challenge` - The hashed `code_verifier`, which is a randomly generated string per request. _Why do we hash the `code_verifier` to create `code_challenge`?_ You need to pass the code to the authorization endpoint securely, and since you're directing the user to a new application context, you cannot be sure that the code is securely transferred from your application to the browser. So you hash it, and after receiving the authorization code, your application can securely send both codes plainly over TLS directly to the authorization endpoint and the server can compute the hash and compare it against what was initially sent.

2. Auth server will handle logging user in, etc, and once finished, redirect you to `redirect_uri`, which should be your site. Auth server is responsible for maintaining sessions, profiles, etc.

3. You should first compare this `state` value to ensure it matches the one you started with. You can typically store the `state` value in a cookie or session, and compare it when the user comes back.
   **This helps ensure your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes as mentioned above.**

4. `code` is the authorization code that you can then use to request an access token. When requesting an access token you send your `code_verifier` and `code` to `oauth/token` endpoint. `code_verifier` serves the same purpose as `client_secret`

Authorization Code Grant is the same but doesn't need a `code_verifier` since it can use `client_secret`. We can't use `client_secret` on client side since it will be exposed, that's why use PCKE (ie. use a `code_verifier` instead of a `client_secret`)

## Implicit Grant (the old, deprecated way of authenticating SPA)

[Source](https://auth0.com/blog/oauth2-implicit-grant-and-spa/)

OAuth2 defines the implicit grant as pretty much any flow that will result in the authorization server issuing a token directly from the authorization (`/authorize`) endpoint, as opposed to issuing it from the token (`/oauth/token`) endpoint.

The original OAuth2 specification introduces the implicit grant in SPAs as the way JavaScript code can obtain access tokens and call APIs directly from a browser. Returning access tokens in a URL (the technique used by the implicit grant for SPAs) is fraught by known systemic issues requiring explicit mitigation. It had to be done this way back then there was no browser support for CORS and we could not request a token from `/oauth/token`. Once there was ubiqtuous browser support for CORS, the PCKE flow was created.

## Silent Authentication

[Source](https://auth0.com/docs/api-auth/tutorials/silent-authentication)

Silent Authentication allows you to get a new access token when your access token expires.

The OpenID Connect protocol supports a prompt=none parameter on the authentication request that allows applications to indicate that the authorization server must not display any user interaction (such as authentication, consent or MFA). Auth0 will either return the requested response back to the application or return an error if the user is not already authenticated, or that some type of consent or prompt is required before proceeding.

To implement silent authentication the previous approach was for a 3rd party session cookie by Auth0 that holds your session and thus knows when your access token expires. Whenever you need to get a new access token, there is a hidden iframe, that will use prompt=none and 3rd party session cookie to get new access token.

Since 3rd party cookies are now being blocked by browsers, we use _refresh token rotation_ for silent authentication.

## Refresh Token Rotation

[Source](https://auth0.com/docs/tokens/concepts/refresh-token-rotation)
[More Info](https://auth0.com/blog/securing-single-page-applications-with-refresh-token-rotation/)

An alternative to silent authentication that does not require a 3rd party session cokie from your auth server is a refresh token. This is a another token that can be used to request a access token once your access token has expired. These are used in native apps.

Unfortunately, long-lived RTs are not suitable for SPAs because there is no persistent storage mechanism in a browser that can assure access by the intended application only. As there are vulnerabilities that can be exploited to obtain these high-value artifacts and grant malicious actors access to protected resources, using refresh tokens in SPAs has been strongly discouraged.

One method to do this is Refresh Token Rotation. By getting a new refresh token along with your new access token every time you use your current refresh token, you prevent the dangers of a single static refresh token being exposed.

Without enforcing sender-constraint using techniques like mTLS or Proof of Possession that require the client to prove it is the same one originally authorized, which are not yet widely adopted, it’s impossible for the Authorization Server (AS) to know which actor is legitimate or malicious in the event of a replay attack. Therefore, it’s important that when a previously-used RT (already invalidated) is sent to the AS that the most recently issued RT is immediately invalidated as well, preventing any RTs in the same token family--all RTs descending from the original RT issued for the client--from being used to get new ATs.

_Note for Auth0 Users_: You want to ensure that rotation is set both on [application](https://auth0.com/docs/tokens/guides/configure-refresh-token-rotation) and on API.
